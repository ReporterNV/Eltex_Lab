ФУНКЦИИ, УКАЗАТЕЛИ
ЦЕЛЬ РАБОТЫ: освоить правила написания и использования функций в языке СИ. 
Научиться использовать указатели при обработке массивов данных.

ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ:
Язык программирования Cи — стандартизированный процедурный язык программирования. 
Язык Cи был создан для использования в операционной системе UNIX, в том числе и для написания ядра системы. 
С тех пор он был портирован на многие другие операционные системы и стал одним из самых широко используемых языков программирования. 
Американский национальный институт стандартов (ANSI) сформировал комитет для разработки стандартной спецификации Си. 
По окончании этого долгого и сложного процесса в 1989 году был наконец утверждён
первый официальный стандарт «Язык программирования Си» ANSI X3.159-1989. 
Эту версию языка принято называть ANSI C или C89. 
В 1990 году стандарт ANSI C был принят с небольшими изменениями Международной организацией по стандартизации (ISO) как ISO/IEC 9899:1990 или С90.
Однако в конце 1990-х годов стандарт подвергся пересмотру, что привело к публикации ISO 9899:1999 в 1999 году. 
Этот стандарт обычно называют «C99». 
В марте 2000 года он был принят и адаптирован ANSI.
8 декабря 2011 опубликован новый стандарт для языка Си (ISO/IEC 9899:2011) или С11.
Для каждого языка программирования, который может компилироваться GCC и для которого существует стандарт, GCC пытается следовать одной или нескольким редакциям этого стандарта, возможно, с некоторыми исключениями и, возможно, с некоторыми расширениями. 
Явно указать, какого стандарта нужно придерживаться при компиляции вашей программы можно, используя ключ компиляции -std, присваивая ему значения, обозначающие тот или иной стандарт:
C90 
-std=-ansi
-std=c90
-std=iso9899:1990

C99
-std=c99
-std=c9x
-std=iso9899:1999
-std=iso9899:199x

C11
-std=C11
-std=c11
-std=c1x
-std=iso9899:2011

По умолчанию GCC использует некоторые расширения языка C, которые довольно редко конфликтуют со стандартом.
Использование ключей -std со значениями в явном виде заблокирует эти расширения.
Потребовать явного использования расширений можно, указав ключи -std=gnu89 или -std=gnu99 для стандартов 1989-го и 1999-го годов, соответственно.
По умолчанию компиляция программ C происходит в режиме -std=gnu89 или -std=gnu99 в зависимости от версии GCC.
Некоторые расширения GCC для стандарта 1989-го года стали частью стандарта 1999.
Разница между стандартами может быть существенной так что одна и таже программу под другим стандартом может не собраться. 
Поэтому особое внимание нужно уделять стандарту и явно его указывать при компиляции.
Так же нельзя надеяться на параметры GCC по умолчанию в зависимости от версии компилятора они могут варьироваться.
Как пример в стандарте C90 были предусмотрены символы /* для обозначения начала комментария и символ */ для обозначения завершения комментария. 
При этом невозможно вложить один комментарий в другой, поскольку первый встреченный символ */ завершит комментарий, и текст, следующий непосредственно за символом */, если этот текст не является программным кодом и содержит произвольный текст, вызовет ошибку компиляции.
Следующий стандарт C99 ввёл ещё один способ оформления комментариев: комментарием считается текст, начинающийся с символа // и заканчивающийся в конце строки.

Некоторые новые особенности C99:
- подставляемые функции (inline); 
- объявление локальных переменных в любом операторе программного текста (как в C++); 
- новые типы данных, такие, как long long int (для облегчения перехода от 32- к 64-битным числам), явный булевый тип данных _Bool и тип complex для представления комплексных чисел; 
- массивы переменной длины; 
- поддержка ограниченных указателей (restrict); 
- именованная инициализация структур: struct { int x, y, z; } point = { .y=10, .z=20, .x=30 }; 
- несколько новых библиотечных функций, таких, как snprintf; 
- несколько новых заголовочных файлов, таких, как stdint.h. 

В стандарте C90 объявление в цикле переменных невозможно. 
Простой пример как одна программа собирается со стандартом c99, а при ключе равном -std=c90 появляется ошибка копиляции на определение цикла:
//--- teststd.c
#include <stdio.h>
int main( int argc, char *argv[] ) {
	for(int i=0; i<5; i++)
		printf("Hello, world!\n" );
}
//---------------
+===============+
$ gcc -Wall -std=c99 teststd.c -o teststd 
$ 
$ gcc -Wall -std=c90 teststd.c -o teststd
teststd.c: В функции «main»:
teststd.c:3:2: ошибка: «for» loop initial declarations are only allowed in C99 mode
  for(int i=0; i<5; i++)
  ^
teststd.c:3:2: замечание: use option -std=c99 or -std=gnu99 to compile your code
teststd.c:5:1: предупреждение: control reaches end of non-void function [-Wreturn-type]
 }
 ^
+===============+

Опция -Wall утилиты gcc - выводит предупреждения, вызванные потенциальными ошибками в коде, не препятствующими компиляции программы, но способными привести, по мнению компилятора, к тем или иным проблемам при её исполнении. 
Важная и полезная опция, разработчики gcc рекомендуют пользоваться ей всегда.
Пример сборки программы с ключем -Wall:
//--- testwall.c
 main(){
 int x;
 int y, z;
 y + 5;
 y = z;
 int *p;
 y = *p;
}
//---------------

+===============+
$ gcc -Wall testwall.c 
testwall.c:1:1: предупреждение: по умолчанию возвращаемый тип функции - «int» [-Wreturn-type]
 main(){
 ^
testwall.c: В функции «main»:
testwall.c:4:2: предупреждение: оператор без побочного эффекта [-Wunused-value]
  y + 5;
  ^
testwall.c:2:6: предупреждение: неиспользуемая переменная «x» [-Wunused-variable]
  int x;
      ^
testwall.c:8:1: предупреждение: control reaches end of non-void function [-Wreturn-type]
 }
 ^
testwall.c:5:4: предупреждение: «z» is used uninitialized in this function [-Wuninitialized]
  y = z;
    ^
testwall.c:7:4: предупреждение: «p» is used uninitialized in this function [-Wuninitialized]
  y = *p;
    ^
+===============+

Опция -Werror - превращает все предупреждения в ошибки. 
В случае появления предупреждения прерывает процесс компиляции. Используется совместно с опцией -Wall.
+===============+
$ gcc -Werror -Wall testwall.c
+===============+

Опции -O1, -O2, -O3 - задают уровень оптимизации кода генерируемого компилятором. 
С увеличением номера, степень оптимизации возрастает. 
Опция -march=architecture - задает целевую архитектуру процессора. 
Список поддерживаемых архитектур обширен, например, для процессоров семейства Intel/AMD можно задать i386, pentium, prescott, opteron-sse3 и т.д. 
Пользователи бинарных дистрибутивов должны иметь в виду, что для корректной работы программ с указанной опцией желательно, что бы и все подключаемые библиотеки были откомпилированы с той же опцией.


ФУНКЦИИ в Си
В языке программирования Си функция в общем виде выглядит следующим образом: 

спецификатор-класса возвращаемый-тип имя-функции(список входных параметров)
{
  тело функции
}

возвращаемый-тип  - это тип данных, возвращаемых функцией, называется также результатом	функции.
Необязательный спецификатор-класса задает класс хранения функции, который может быть static или extern.
Далее параметром мы будем называть переменную из списка параметров, заключенного в круглые скобки и заданного в определении функции, а аргументом - значение, используемое при обращении к функции. 
Иногда в том же смысле мы будем употреблять термины формальный аргумент и фактический аргумент. 
В современных, правильно написанных программах на языке Си каждую функцию перед использованием необходимо объявлять.
Функции в языке Си по старому образцу оформляются следующим образом: 

//---
/* прототип функции */ 
long func(int, int, int*); 

/ * описание функции * / 
long func (a, b) /* имя-функции(список входных параметров) */
	int a,b;   /* описание формальных параметров */
{ 
	long х; /* описание локальных переменных */
	/* тело функции */
	return x; /* возврат результата через имя функции */
} 
//---

Список входных параметров — это список, элементы которого отделяются друг от друга запятыми(тип имя_параметра_1, тип имя_параметра_2, ...). 
Каждый такой элемент состоит из имени переменной и ее типа данных. 
Аргументы функции — это значения, которые подаются на вход функции. 
При вызове функции параметры принимают значения аргументов.
Пример вызова функции и передача аргументов через список параметров функции, вывод значения агрументов на экран:
//--- myfunc1.c
#include <stdio.h>
int myfunc(int a, int b, float c){
	//тело функции
	printf("a=%d b=%d c=%f", a, b, c);
	return 0;
}

int main( int argc, char *argv[] ) {
	myfunc(1,2,3);//вызов функции, 1,2,3 — аргументы функции.
	return 0;
}
//---------------

+===============+
$ gcc -Wall -std=c99 myfunc1.c -o myfunc1
$ ./myfunc1
a = 1 b = 2 c = 3.000000
+===============+

Функция может быть и без параметров, тогда их список будет пустым. 
Такой пустой список можно указать в явном виде, поместив для этого внутри скобок ключевое слово void.
//--- myfunc2.c
int myfunc(void){
	//тело функции
}
//---------------

Если список параметров пустой и не указано ключевое слово void, то это воспринимается как неизвестное количество параметров функции или функция с неизвестным количеством входных параметров.
//--- myfunc3.c
int myfunc(){
	//тело функции
}
//---------------

ПРОТОТИП ФУНКЦИИ
В языке Си описать функцию можно с помощью прототипа функции. 
Прототип функции (или ее объявление) задает имя, возвращаемый тип и класс хранения для функции, полное определение которой содержится в каком-либо другом месте программы. 
Прототип также может содержать объявления, задающие тип и число формальных параметров функции. 
Прототип функции имеет тот же вид, что и определение функции, за тем исключением, что прототип заканчивается точкой с запятой. 
Компилятор использует прототип или объявление для сравнения типов действительных аргументов в вызове функции с формальными параметрами функции, даже если явное определение функции отсутствует. 
Явное задание прототипов и объявлений для функций, возвращающих значение int необязательно. 
Однако, для обеспечения корректности выполнения нужно обязательно объявить или определить функции с другими возвращаемыми типами до их вызова.
Эту роль как раз и выполняет прототип. 
В примере по мере компиляции кода программы сверху-вниз компилятор встретит прототип и вызов фунции до ее объявления и не будет ошибки компиляции:
//--- protofunc.c
#include <stdio.h>
int myfunc(int a, int b, float c); //прототип функции
int main( int argc, char *argv[] ) {
	myfunc(1,2,3);//вызов функции, 1,2,3 — аргументы функции.
	return 0;
}
int myfunc(int a, int b, float c){ //описание функции
	//тело функции
	printf("a=%d b=%d c=%f", a, b, c);
	return 0;
}
//---------------
+===============+
$ gcc -Wall -std=c99 protofunc.c -o protofunc
$ ./myfunc1
a = 1 b = 2 c = 3.000000
+===============+

ОБЛАСТЬ ДЕЙСТВИЯ ФУНКЦИИ
Каждая функция представляет собой конечный блок кода.
Таким образом, она определяет область действия этого блока. 
Это значит, что код функции является закрытым и недоступным ни для какого выражения из любой другой функции, если только не выполняется вызов содержащей его функции.
Код и данные, определенные внутри одной функции, без глобальных переменных не могут воздействовать на код и данные внутри другой функции, так как у любых двух разных функций разные области действия.
Переменные, определенные внутри функции, являются локальными.
Локальная переменная создается в начале выполнения функции, а при выходе из этой функции она уничтожается.
Таким образом, локальная переменная не может сохранять свое значение в промежутках между вызовами функции.
Формальные параметры функции также находятся в ее области действия. 
Это значит, что параметр доступен внутри всей функции.
Параметр создается в начале выполнения функции, и уничтожается при выходе из нее.
В примере показано как локальная переменная функции не влияет на глобальную переменную с тем же именем:  
//--- global.c
#include <stdio.h>
int x = 5; //Глобальная переменная
int add(int a, int b){
	int x = a + b; // локальная переменная
	printf("x-local=%d", x);
	return x;
}
int main( int argc, char *argv[] ) {
	int y = add(1, 2);
	printf("y=%d", y);
	printf("x-global=%d", x);
	return 0;
}
//---------------
+===============+
$ gcc -Wall -std=c99 global.c -o global
$ ./global
x-local=3y=3x-global=5
+===============+

ЧТО ВОЗВРАЩАЕТ ФУНКЦИЯ И ОПЕРАТОР RETURN 
Функция может завершать выполнение и осуществлять возврат в вызывающую программу.
Все функции, кроме тех, которые относятся к типу void, возвращают значение.
Это значение указывается выражением в операторе return.
Стандарте С99 предусмотрено, что в функции, тип которой отличен от void, в операторе return необходимо обязательно указать возвращаемое значение.
Если функция не объявлена как имеющая тип void, она может использоваться как операнд в выражении. 
Пример функции которая возвращает int и функция которая использует глобальную переменную x для возврата значения:
//--- myfunc4.c
#include <stdio.h>
int x; //Глобальная переменная
int add(int a, int b){ //функция возвращает int
	//тело функции
	return a + b; //возврат результата 
}
void addvoid(int a, int b){
	x = a + b;
}

int main( int argc, char *argv[] ) {
	x = add(1,2);
	x = add(1, add(2,3));
	addvoid(x, x);
	printf("x=%d", x);
	return 0;
}
//---------------

+===============+
$ gcc -Wall -std=c99 myfunc4.c -o myfunc4
$ ./myfunc4
x=12
+===============+

ВЫЗОВ ФУНКЦИИ И ПЕРЕДАЧА АРГУМЕНТОВ ПО ЗНАЧЕНИЮ
В Си все аргументы функции передаются “по значению”. 
Это следует понимать так, что вызываемой функции посылаются значения ее аргументов во временных переменных, а не сами аргументы. 
В Си вызываемая функция не может непосредственно изменить переменную вызывающей функции: она может изменить только ее частную, временную копию. 
Однако вызов по значению следует отнести к достоинствам языка, а не к его недостаткам.
Благодаря этому свойству обычно удается написать более компактную программу, содержащую меньшее число посторонних переменных, поскольку параметры можно рассматривать как должным образом инициализированные локальные переменные вызванной подпрограммы. 
В качестве примера приведем версию функции power, в которой как раз использовано это свойство:
//--- power.c
/* power: возводит base в n-ю степень; n >= 0, версия 2 */
#include <stdio.h>
int power(int base, int n)
{
    int p;
    for (p = 1; n > 0; --n)
        p = p * base;
    return p;
}
int main( int argc, char *argv[] ) {
	int base = 2;
	int n = 3;
	printf("power=%d\n", power(base, n));
	printf("n=%d", n);
}
//---------------

+===============+
$ gcc -Wall -std=c99 power.c -o power
$ ./power
power=8
n=3
+===============+

В функции power параметр n выступает здесь в роли временной переменной, в которой циклом for в убывающем порядке ведется счет числа шагов до тех пор, пока ее значение не станет нулем.
При этом отпадает надобность в дополнительной переменной i для счетчика цикла. 
Что бы мы ни делали с n внутри power, это не окажет никакого влияния на сам аргумент, копия которого была передана функции power при ее вызове. 

УКАЗАТЕЛИ
Указатель - это переменная, содержащая адрес переменной.
Указатель не несет информации о содержимом объекта, а содержит сведения о том, где размещен объект. 
Отличие указателей от машинных адресов состоит в том, что указатель может содержать адреса данных только определенного типа.
Указатели широко используются в программировании на языке Си.
Программы с указателями обычно короче и эффективнее.
Указатель, как и любая переменная, должен быть объявлен.
Общая форма объявления указателя:
	тип  *имя_указателя;

Тип - это тип переменной, адрес которой содержит указатель.
Для работы с указателями в Си определены две операции:
Операция * (звездочка) — позволяет получить значение объекта по его адресу - определяет значение переменной, которое содержится по адресу, содержащемуся в указателе; 
Операция & (амперсанд) — позволяет определить адрес переменной.
Унарные операторы * и & имеют более высокий приоритет, чем арифметические операторы.
//--- pointer.c
#include <stdio.h>
int main( int argc, char *argv[] ) {
	int x = 10; //Объявление переменной типа int и присваивание ей 10
	int *p; //Объявление указателя
	p = &x; 
/* Присваивание указателю p адреса переменной x 
   (указатель будет ссылаться на x)
*/
	*p = 11; //Разыменование указателя и присваивание значения 11
	printf("x=%d\n", x);
	printf("*p=%d\n", *p);
	printf("p=%p\n", p);
	printf("&x=%p\n", &x);
	printf("&p=%p\n", &p);
}
//---------------

+===============+
$ gcc -std=c99 -Wall pointer.c -o pointer
$ ./pointer
x=11
*p=11
p=0x7fff38e684ec
&x=0x7fff38e684ec
&p=0x7fff38e684e0
+===============+

p : 0x7ff..e0        x : 0x7ff..ec
-------------        ----------
| Data      |        | Data   |
-------------        ----------
| 0x7ff..ec | - - -> | 10     |
-------------        ----------
Указателю можно присвоить значение другого указателя на такой же тип. 
В результате оба указателя будут указывать на одно и то же место в памяти.
Указатель на один тип можно преобразовать в указатель на другой тип.
Такое преобразование не вызывает генерации каких-либо машинных команд, но заставляет компилятор изменить параметры адресной арифметики, а также операции выборки данного по указателю.

ВЫЗОВ ФУНКЦИИ И ПЕРЕДАЧА АРГУМЕНТОВ ПО ССЫЛКЕ
Хотя в С для передачи параметров функции применяется вызов по значению, можно создать вызов и по ссылке, передавая не сам аргумент, а указатель на него. 
Так как функции передается адрес аргумента, то ее внутренний код в состоянии изменить значение этого аргумента, находящегося, между прочим, за пределами самой функции.
Указатель передается функции так, как и любой другой аргумент. 
Конечно, в таком случае параметр следует декларировать как один из типов указателей. 
Это можно увидеть на примере функции swap(), которая меняет местами значения двух целых переменных, на которые указывают аргументы этой функции.
Функция swap() может выполнять обмен значениями двух переменных, на которые указывают х и y, потому что передаются их адреса, а не значения. 
Внутри функции, используя стандартные операции с указателями, можно получить доступ к содержимому переменных и провести обмен их значений.
 
//--- swap.c
#include <stdio.h>
void swap(int *x, int *y){
  int temp;
  temp = *x;  /* сохранить значение по адресу x */
  *x = *y;    /* поместить y в x */
  *y = temp;  /* поместить x в y */
}
int main(int argc, char *argv[]){
  int i = 10, j = 20;
  printf("i и j перед обменом значениями: %d %d\n", i, j);
  swap(&i, &j); /* передать адреса переменных i и j */
  printf("i и j после обмена значениями: %d %d\n", i, j);
  return 0;
}
//---------------

+===============+
$gcc -Wall -std=c99 swap.c -o swap
$ ./swap
i и j перед обменом значениями: 10 20
i и j после обмена значениями: 20 10
+===============+

В примере переменной i присваивается значение 10, а переменной j — значение 20.
Затем вызывается функция swap() с адресами этих переменных.
Для получения адреса каждой из переменных используется унарный оператор &. Поэтому в функцию swap() передаются адреса переменных i и j, а не их значения.
 
УКАЗАТЕЛИ И МАССИВЫ
Указатели и массивы тесно связаны друг с другом.
В Си существует связь между указателями и массивами, и связь эта настолько тесная, что эти средства лучше рассматривать вместе.
Между индексированием и арифметикой с указателями также существует очень тесная связь.
По определению значение переменной или выражения типа массив есть адрес нулевого элемента массива.
После присваивания (см. Пример arrpointer.c): 
	p = &a[0];
р и a имеют одно и то же значение.
Любой доступ к элементу массива, осуществляемый операцией индексирования, может быть выполнен с помощью указателя. 

	массив			указатель
       ____________        _____
	a: | a[0]      |<--- p:| *  |
	   | a[1]      |       сейчас равен p = &a[0]
	   | a[2]      |                    p[0] = a[0]
	   |  ...      |

Указатели можно индексировать подобно массивам.
	a[i]  тождественно *(p+i)
	&a[i] тождественно   p+i
Между именем массива и указателем, выступающим в роли имени массива, существует одно различие.
Указатель - это переменная, поэтому можно написать p=a или p++.
Но имя массива не является переменной, и записи вроде a=p или a++ не допускаются.
Имя массива - это константа, представляющая собой указатель на 0-ой элемент массива.
Этот указатель отличается от обычных тем, что его нельзя изменить (установить на другую переменную), поскольку он сам хранится не в переменной, а является просто некоторым постоянным адресом.
Результат выполнения программы arrpointer.c у всех будет разный и возможно будет отличаться при каждом запуске, т.к. не была осуществена начальная инициализация массива.
В языке Си массивы, указатели и переменные по умолчанию не обнуляются как в других языках программирования и программист сам должен задавать начальные значения или проводить принудительное обнуление.
//--- arrpointer.c
#include <stdio.h>
#define N 10

int main( int argc, char *argv[] ) {
	int a[N]; //объявление массива
	for (int i = 0; i < N; i++){
		printf("a[%d]=%d ", i, a[i]); //доступ по индексу i
	}
	printf("\n");
	int *p = &a[0];
	for (int i = 0; i < N; i++){
		printf("p[%d]=%d ", i, p[i]); //доступ через p по индексу i
	}
	printf("\n");
	p = a;
	for (int i = 0; i < N; i++){
		printf("*(p+%d)=%d ", i, *(p+i)); //адресная арифметика
	}
	printf("\n");
}
//---------------

+===============+
$ gcc -std=c99 -Wall arrpointer.c -o arrpointer
$ ./arrpointer
+===============+

Поскольку имя массива является синонимом расположения его начального элемента, присваивание p=&a[0] можно также записать в следующем виде: 
	p = a;
Если p есть указатель на некоторый элемент массива, то p++ увеличивает p так, чтобы он указывал на следующий элемент, а p+=i увеличивает его, чтобы он указывал на i-й элемент после того, на который указывал ранее. 
Эти и подобные конструкции - самые простые примеры арифметики над указателями, называемой также адресной арифметикой.
Си последователен и единообразен в своем подходе к адресной арифметике.
Соединение в одном языке указателей, массивов и адресной арифметики - одна из сильных сторон Си.
//--- arrpointer2.c
#include <stdio.h>
#define N 10

int main( int argc, char *argv[] ) {
	int a[N] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	int *p = a;
	for (int i = 0; i < N; i++){
		printf("*(p+%d)=%d", i, *(p+i)); //адресная арифметика
	}
	printf("\n");
	p = a;
	for (int i = 0; i < N; i++){
		printf("p[%d]=%d", i, p[i]); //доступ через p по индексу i
	}

	printf("\n");
} 

//---------------

+===============+
$ gcc -std=c99 -Wall arrpointer2.c -o arrpointer2
$ ./arrpointer2
*(p+0)=0*(p+1)=1*(p+2)=2*(p+3)=3*(p+4)=4*(p+5)=5*(p+6)=6*(p+7)=7*(p+8)=8*(p+9)=9
p[0]=0p[1]=1p[2]=2p[3]=3p[4]=4p[5]=5p[6]=6p[7]=7p[8]=8p[9]=9
+===============+

В общем случае указатель, как и любую другую переменную, нужно инициализировать, но только такими осмысленными для него значениями, как нуль(NULL) или выражение, приводящее к адресу ранее определенных данных соответствующего типа.
В Си принято соглашение, что указатель 0 означает "указатель ни на что". 
Он является просто признаком, используемым для обозначения несуществующего адреса или конца цепочки указателей, и имеет специальное обозначение NULL.
Обращение (выборка или запись данных) по этому указателю считается некорректным (кроме случая, когда вы пишете машинно-зависимую программу и работаете с физическими адресами).
Само присваивание указателю некорректного значения еще не является ошибкой. Ошибка возникнет лишь при обращении к данным по этому указателю (такие ошибки довольно тяжело искать!). 
//--- errorpointer.c
#include <stdio.h>
int main(int argc, char **argv){
	int *iptr;
    // printf("%d\n", *iptr); //Ошибка сегментирования (core dumped)
    // *iptr = 10; //Ошибка сегментирования (core dumped)
	
	int i = 2;
	double x = 12.06;
	
	iptr= &i;	
	printf("%d\n", *iptr);
	printf("%d\n", *(iptr+1));
	iptr += 7;  /* куда же он указал ?! */

	iptr = (int *)&x; 
	i = *iptr;
	printf("%d\n", i);
	
	double y = *((double *)iptr); 
	printf("%f\n", y);
}
//---------------
При передаче имени массива в качестве параметра функции,как аргумент передается не копия САМОГО МАССИВА (это заняло бы слишком много места), а копия АДРЕСА 0-ого элемента этого массива (т.е. указатель на начало массива).
Заметьте, что поскольку массив передается как указатель на его начало, то размер массива в объявлении аргумента можно не указывать.
Это позволяет одной функцией обрабатывать массивы разной длины:
    вместо    Fun(int a[5]) { ... }
    можно     Fun(int a[] ) { ... }
    или даже  Fun(int *p  ) { ... }
Если функция должна знать длину массива - передавайте ее как дополнительный аргумент.
//--- argarray.c
#include <stdio.h>
int sum( int a[], int len ){
	int s = 0;
	for(int i=0; i<len; i++) 
		s += a[i];
	return s;
}

double mean( int *a, int len ){
	double s = 0;
	for(int i=0; i<len; i++) 
		s += a[i];
	return s/len;
}

int main(int argc, char **argv){
	int a[] = {1, 2, 3};
	printf("Сумма массива:%d\n", sum(a, 3));
	printf("Среднее массива:%f\n", mean(a, 3));
}
//---------------
Так как в качестве параметра функции передается копия АДРЕСА 0-ого элемента массива (т.е. указатель на начало массива), то следует быть внимательным при работе с функцией strlen() и оператором sizeof.
	size_t strlen(const char *str);
Функция strlen() возвращает длину строки, адресуемой параметром str, причем строка должна заканчиваться символом конца строки.
Символ конца строки ('\0') или (0) не учитывается.
Когда имя массива используется в операторе sizeof, то оно не преобразуется к указателю на свой первый элемент.
Оператор sizeof подсчитывает размер любой переменной или любого типа и может быть полезен, если в программах требуется свести к минимуму машинно-зависимый код.
sizeof — это оператор который срабатывает во временя компиляции, вся информация, необходимая для вычисления размера любой переменной, становится известной как раз во время компиляции.
Это особенно важно для объединений union, потому что размер каждого из них всегда равен размеру наибольшего члена.
Ниже пример который демострирует разницу между размером длины массива и размером указателя который передается в качестве параметра функции.
//--- sizeof.c
#include <string.h>
#define LEN 10
void print(char *text, char *mas){
	printf("%s = %s, sizeof=%ld, strlen=%ld\n", text, mas, sizeof(mas), strlen(mas));
}	

void showMas2(char *mas){
		mas[2] = 'C';
		mas[3] = 'D';
		print("showMas2", mas);
}

void showMas(char mas[]){
		mas[0] = 'A';
		mas[1] = 'B';
		print("showMas", mas);
		showMas2(mas);
		print("showMas", mas);
}

int main(int argc, char **argv){
	char mas[LEN];
	memset(mas, '\0', LEN);
	printf("mas = %s, sizeof=%ld, strlen=%ld\n", mas, sizeof(mas), strlen(mas));
	//print("mas", mas);
	showMas(mas);
	return 0;
}
//---------------

+===============+
$ gcc -std=c99 -Wall sizeof.c -o sizeof
$ ./sizeof
mas = , sizeof=10, strlen=0
showMas = AB, sizeof=8, strlen=2
showMas2 = ABCD, sizeof=8, strlen=4
showMas = ABCD, sizeof=8, strlen=4
+===============+

Объем памяти, необходимый для хранения массива, непосредственно определяется его типом и размером.
Для одномерного массива количество байтов памяти вычисляется следующим образом: 
	количество_байтов = sizeof(базовый_тип) × длина_массива
Оператор sizeof возвращает размер типа выражения, указанного в качестве операнда.
При этом особенностью sizeof является то, что если указанное в качестве операнда выражение имеет тип "массив", то традиционного автоматического преобразования к типу "указатель" не производится.
Таким образом  sizeof можно использовать для вычисления длины массива.
	int m[4];
	sizeof(m); is 8 or 16 byte
	sizeof(&m); is 8 byte
	sizeof(*m); is 2 or 4 byte
sizeof(m) имеет значение равное 4 * sizeof( int ) , и если переменная типа int имеет размер равный 4 байта, то предыдущее выражение вернет значение равное 16 байт. 
Главное не забывать, что при передачи массива в качестве параметра функции будет автоматически создана копия АДРЕСА 0-ого элемента этого массива.
Ниже пример показывает использование имени массива в операторе sizeof, для вычисления длины массива в функции main:
//--- sizeofarray.c
#include <stdio.h>
#include <string.h>

//неверно пишет длину массива
void len(char *name, int mas[]) {
	printf("%s funclen=%ld\n", name, sizeof(mas)/sizeof(int));
}	

int main(int argc, char **argv){
	int mas[3] = {0, 1, 3};
	int mas2[5] = {3, 4, 5, 6, 7};
	printf("mas len=%ld\n", sizeof(mas)/sizeof(int));
	len("mas", mas);
	printf("mas2 len=%ld\n", sizeof(mas2)/sizeof(int));
	len("mas2", mas2);
	return 0;
}
//---------------

+===============+
mas len=3
mas funclen=2
mas2 len=5
mas2 funclen=2
+===============+

ДИНАМИЧЕСКОЕ ВЫДЕЛЕНИЕ ПАМЯТИ
Динамическое выделения памяти означает, что программа выделяет память для данных во время своего выполнения.
Память для глобальных переменных выделяется во время компиляции.
Для нестатических локальных переменных — в стеке. 
Во время выполнения программы ни глобальным, ни локальным переменным не может быть выделена дополнительная память. 
Но довольно часто такая необходимость возникает, причем объем требуемой памяти заранее неизвестен.
Память, выделяемая в Си функциями динамического выделения памяти, находится в динамически распределяемой области памяти (heap).
Динамически распределяемая область памяти — это свободная область памяти, не используемая программой, операционной системой или другими программами. 
Размер динамически распределяемой области памяти заранее неизвестен, но как правило в ней достаточно памяти для размещения данных программы.
Хотя размер динамически распределяемой области памяти очень большой, все же она конечна и может быть исчерпана.
Функции malloc и calloc динамически запрашивают блоки свободной памяти. 

Функция malloc:
	void *malloc(size_t n)
возвращает указатель на n байт неинициализированной памяти или NULL, если запрос удовлетворить нельзя. 

Функция calloc:
	void *calloc(size_t n, size_t size)
возвращает указатель на область, достаточную для хранения массива из n объектов указанного размера (size), или NULL, если запрос не удается удовлетворить.
Выделенная память обнуляется.
Указатель, возвращаемый функциями malloc и calloc, будет выдан с учетом выравнивания, выполненного согласно указанному типу объекта. 
Тем не менее к нему должна быть применена операция приведения к соответствующему типу.

Функция realloc:
	void *realloc(void *p, size_t size)
realloc заменяет на size размер объекта, на который указывает p. 
Для части, размер которой равен наименьшему из старого и нового размеров, содержимое не изменяется. 
Если новый размер больше старого, дополнительное пространство не инициализируется, realloc возвращает указатель на новое место памяти или, если требования не могут быть удовлетворены, NULL.

Функция free:
	void free(void *р)
Функция free(p) освобождает область памяти, на которую указывает p, - указатель, первоначально полученный с помощью malloc, calloc или realloc.  
Никаких ограничений на порядок, в котором будет освобождаться память, нет, но считается ужасной ошибкой освобождение тех областей, которые не были получены с помощью calloc или malloc.
Нельзя также использовать те области памяти, которые уже освобождены. 
Пример использования динамического выделения памяти:
//--- malloc.c
#include <stdio.h>
#include <stdlib.h>
#define N 5
int main( int argc, char *argv[] ) {
	int *p = NULL;

	p = (int *) malloc(N*sizeof(int));
	if(!p) {
		printf("Требуемая память не выделена[malloc].\n");
		exit(1);
	}
	for (int i = 0; i < N; i++){
		printf("p[%d]=%d ", i, p[i]); //доступ через p по индексу i
	}
	printf("\n");
	free(p);

	p = (int *) calloc(N, sizeof(int));
	if(!p) {
		printf("Требуемая память не выделена[calloc].\n");
		exit(1);
	}
	for (int i = 0; i < N; i++){
		printf("*(p+%d)=%d ", i, *(p+i)); //адресная арифметика
	}
	printf("\n");
	free(p);
}
//---------------
Если в примере malloc.c закоментировать функции free, то выполнение программы может привести к утечке памяти.

УТЕЧКИ ПАМЯТИ И СПОСОБЫ ОБНАРУЖЕНИЯ
Утечка памяти  - процесс неконтролируемого уменьшения объёма свободной оперативной или виртуальной памяти, связанный с ошибками в работающих программах, вовремя не освобождающих ненужные участки памяти.
Динамическая память является ограниченным ресурсом.
Для обнаружения утечки памяти можно воспользоваться функцией mtrace.

//--- mtrace.c
#include <mcheck.h>
#include <stdlib.h>
int main(int argc, char *argv[]){
	int j;
	mtrace(); /* подключаем логи вначале программы */
	for (j = 0; j < 2; j++)
		malloc(100);            /* никогда не освободиться - утечка */
        calloc(16, 16);             /* никогда не освободиться - утечка */
        exit(EXIT_SUCCESS);
}
+===============+
$ gcc -std=c99 -Wall t_mtrace.c -o t_mtrace
$ export MALLOC_TRACE=/tmp/t
$ ./t_mtrace
$ mtrace ./t_mtrace $MALLOC_TRACE
	или
$ cat $MALLOC_TRACE
+===============+

Так же для обнаружения утечки памяти можно использовать утилиту Valgrind.
Valgrind хорошо известен как мощное средство поиска ошибок работы с памятью.
В его составе имеется некоторое количество дополнительных утилит, предназначенных для профилирования программ, анализа потребления памяти и поиска ошибок связанных с синхронизацией в многопоточных программах.
Перед тем как пользоваться утилитой Valgrind рекомендуется пересобрать программу с отладочной информацией и отключенной оптимизацией используя флаги компиляции -g и -O0.
Утилиту Valgrind необходиму установить:
+===============+
$ gcc -std=c99 -Wall -g -O0 t_mtrace.c -o t_mtrace
$ sudo apt-get install valgrind
$ valgrind --leak-check=full --leak-resolution=med ./t_mtrace
  или общая схема если есть аргументы командной строки
$ valgrind --leak-check=full --leak-resolution=med программа аргументы
+===============+

СИМВОЛЬНЫЕ УКАЗАТЕЛИ И СТРОКИ
Одномерный массив наиболее часто применяется в виде строки символов. 
Строка — это одномерный массив символов, заканчивающийся нулевым символом. 
В языке С признаком окончания строки (нулевым символом) служит символ '\0'.
Таким образом, строка содержит символы, составляющие строку, а также нулевой символ. 
Это единственный вид строки, определенный в С.
Объявляя массив символов, предназначенный для хранения строки, необходимо предусмотреть место для нуля, т.е. указать его размер в объявлении на один символ больше, чем наибольшее предполагаемое количество символов.
//--- string.c
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv){
	char s1[80], s2[80];
	scanf("%s", s1);
	scanf("%s", s2);
	printf("Длина: %d %d\n", strlen(s1), strlen(s2));
	if(!strcmp(s1, s2)) 
		printf("Строки равны\n");
	strcat(s1, s2);
	printf("%s\n", s1);
	strcpy(s1, "Проверка.\n");
	printf(s1);
	if(strchr("Алло", 'e')) printf(" л есть в Алло\n");
	if(strstr("Привет", "ив")) printf(" найдено ив ");
  return 0;
}
//---------------

Строковая константа, написанная в виде:
	"Я строка"
есть массив символов. Во внутреннем представлении этот массив заканчивается нулевым символом '\0', по которому программа может найти конец строки. 
Число занятых ячеек памяти на одну больше, чем количество символов, помещенных между двойными кавычками. 
Если, например, переменную p объявить как:
	char *p;
то присваивание:
	p = "now is the time";
поместит в нее указатель на символьный массив, при этом сама строка не копируется, копируется лишь указатель на нее. 
Операции для работы со строкой как с единым целым в Си не предусмотрены. 
Существует важное различие между следующими определениями: 
char message[] = "now is the time"; /* массив */
char *p = "now is the time";  /* указатель на строковую константу*/
message - это массив, имеющий такой объем, что в нем как раз помещается указанная последовательность символов и '\0'. 
Отдельные символы внутри массива могут изменяться, но message всегда указывает на одно и то же место памяти. 
В противоположность ему p есть указатель, инициализированный так, чтобы указывать на строковую константу. 
А значение указателя можно изменить, и тогда последний будет указывать на что-либо другое. 
Кроме того, результат будет неопределен, если вы попытаетесь изменить содержимое константы. 
//--- string2.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void printMas(char *mas, int count){
    for (int i = 0; i < count ; i++){
        printf("%c", mas[i]);
    }
    printf("\n");
}

int main(int argc, char **argv){

	char message[] = "now is the time"; /* массив */
	char *p = "now is the time";  /* указатель на строковую константу*/
	message[0] = '?';
	printMas(message, strlen(message));
	//p[0] = "?"; //приведет к ошибке сегментирования (core dumped)
	printMas(p, strlen(p));
}
//---------------

МАССИВЫ УКАЗАТЕЛЕЙ
Как и объекты любых других типов, указатели могут быть собраны в массив.
Для передачи массива указателей в функцию используется тот же метод, что и для любого другого массива: имя массива без индекса записывается как формальный параметр функции.
Массивы указателей часто используются при работе со строками.
В примере month.c функция month_name(n) возвращает указатель на строку символов, содержащий название n-го месяца. 
Функция month_name через переметры функции имеет в своем личном распоряжении массив строк, на одну из которых она и возвращает указатель.
//--- month.c
#include <stdio.h>
char *months[] = {
        "Неверный месяц",
        "Январь","Февраль","Март","Апрель","Май","Июнь", 
        "Июль","Август","Сентябрь","Октябрь","Ноябрь","Декабрь"
};

char *months_en[] = {
	"Invalid month",
	"January", "February", "March", "April", "May", "June",
	"July", "August", "September", "October", "November", "December"
};         
/* month_name: возвращает имя n-го месяца */
char *month_name(char *name[], int n){
    return (n < 1 || n > 12) ? name[0] : name[n];
}

int main(int argc, char **argv){
	printf("Введите номер месяца:");
	int n = 0;
	scanf("%d", &n);
	printf("Месяц:%s\n", month_name(months, n));
	printf("Month:%s\n", month_name(months_en, n));
}
//---------------

МНОГОУРОВНЕВАЯ АДРЕСАЦИЯ
Иногда указатель может ссылаться на указатель, который ссылается на число. 
Это называется многоуровневой адресацией. 
   Указатель         Переменная
       +--------+        +--------+
       | Адрес  |------->|Значение|
       +--------+        +--------+
          Одноуровневая адресация

Указатель       Указатель       Переменная
+--------+      +--------+      +--------+
| Адрес  |----->| Адрес  |----->|Значение|
+--------+      +--------+      +--------+
          Многоуровневая адресация

Иногда применение таких указателей существенно усложняет программу, делает ее плохо читаемой и подверженной ошибкам.
Переменная, являющаяся указателем на указатель, должна быть соответствующим образом объявлена. 
Это делается с помощью двух звездочек перед именем переменной.
При двухуровневой адресации для доступа к значению объекта нужно поставить перед идентификатором две звездочки: 
//--- pointer2.c
#include <stdio.h>
int main(int argc, char **argv){
  int x = 10, *p, **q;
  p = &x;
  q = &p;
  printf("%d", **q); /* печать значения x */
  return 0;
}
//---------------
Здесь p объявлена как указатель на целое, a q — как указатель на указатель на целое. Функция printf() выводит на экран число 10. 
Пример демонстрирующий динамическое выделение памяти для массива строк и многоуровневую адресацию:
//--- array.c
#include <stdio.h>
#include <stdlib.h>
#include <mcheck.h> /* для mtrace */
#include <string.h>
#define MAX_LEN 1024 /* максимальная длина строки */

char** readMas(int count){
	char buffer[MAX_LEN];
	char **mas;  //указатель на массив указателей на строки
	mas = (char **)malloc(sizeof(char *)*count);// выделяем память для массива указателей
    for (int i = 0; i < count ; i++){
        scanf("%s", buffer); // читаем строку в буфер
        mas[i] = (char *)malloc(sizeof(char)*strlen(buffer)); //выделяем память для строки
        strcpy(mas[i], buffer); //копируем строку из буфера в массив указателей
    }
    return mas; 
}

void printMas(char **mas, int count){
    for (int i = 0; i < count ; i++){
        printf("%s\n", mas[i]);
    }
}

void freeMas(char **mas, int count){
	for (int i = 0; i < count; i++){
        free(mas[i]); // освобождаем память для отдельной строки
    }
    free(mas); // освобождаем памать для массива указателей на строки
}

int main(int argc, char **argv){

	char **mas = NULL; //указатель на массив указателей на строки
	int count = 3;
	mtrace();
	mas = readMas(count);
	printMas(mas, count);
	freeMas(mas, count);
}
//---------------

+===============+
$ gcc -Wall -o array array.c -std=c99
$ export MALLOC_TRACE=/tmp/t
$ ./array
Hello
World
!
Hello
World
!
$ cat /tmp/t
= Start
@ ./array:[0x400736] + 0x2191460 0x18
@ ./array:[0x400788] + 0x2191480 0x5
@ ./array:[0x400788] + 0x21914a0 0x5
@ ./array:[0x400788] + 0x21914c0 0x1
@ ./array:[0x40084d] - 0x2191480
@ ./array:[0x40084d] - 0x21914a0
@ ./array:[0x40084d] - 0x21914c0
@ ./array:[0x400865] - 0x2191460
+===============+

УКАЗАТЕЛИ НА ФУНКЦИИ
Указатели на функции — очень мощное средство языка С.
Функция располагается в памяти по определенному адресу, который можно присвоить указателю в качестве его значения.
Адресом функции является ее точка входа. Именно этот адрес используется при вызове функции.
Так как указатель хранит адрес функции, то она может быть вызвана с помощью этого указателя.
Он позволяет также передавать ее другим функциям в качестве аргумента.
В программе на Си адресом функции служит ее имя без скобок и аргументов.

//--- check.c
#include <stdio.h>
#include <string.h>
#define MAX_LEN 80
void check(char *a, char *b, int (*cmp)(const char *, const char *)){
	printf("Проверка на совпадение.\n");
	if(!(*cmp)(a, b)) 
		printf("Равны");
	else 
		printf("Не равны");
}

int main(int argc, char **argv){
  char s1[MAX_LEN], s2[MAX_LEN];
  int (*p)(const char *, const char *); /* указатель на функцию */
  p = strcmp;   /* присваивает адрес функции strcmp указателю p */
  printf("Введите две строки.\n");
  fgets(s1, MAX_LEN, stdin);
  fgets(s2, MAX_LEN, stdin);
  check(s1, s2, p); /* Передает адрес функции strcmp
                       посредством указателя p */
  return 0;
}
//---------------
 
БЫСТРАЯ СОРТИРОВКА
Пример программы, которая с помощью функции qsort сортирует строки, переданные в качестве аргументов через командную строку:
//--- qsort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
static int cmpstringp(const void *p1, const void *p2){
           /* Аргументами данной функции являются "pointers to
              pointers to char", однако аргументами strcmp(3)
              являются "pointers to char", так что здесь происходит
              преобразование и разыменовывание ссылок */
	return strcmp(*(char * const*)p1, *(char* const*)p2);
}
int main(int argc, char *argv[]){
	int j;
	if (argc < 2) {
		fprintf(stderr, "Usage: %s <string>...\n", argv[0]);
		exit(EXIT_FAILURE);
	}
	qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);
	for (j = 1; j < argc; j++){
		puts(argv[j]);
	}
	exit(EXIT_SUCCESS);
}
//---------------

+===============+
$ gcc -Wall -std=c99 sort.c -o sort
$ ./sort abcd dac zac bak
abcd
bak
dac
zac
+===============+

Функцию  cmpstringp можно записать немного в другой форме для лучшего понимания преобразования типов:
//---------------
static int cmpstringp(const void *p1, const void *p2){
	char **str1 = (char **)p1;
	char **str2 = (char **)p2;
	return strcmp(*str1, *str2);
}
//---------------

?===============?
ЗАДАНИЕ:
Написать программу сортировки массива строк по вариантам.
Строки вводить с клавиатуры. Сначала пользователь вводит кол-во строк потом сами строки. 
Для тестирования использовать перенаправление ввода-вывода ($./myprog < test.txt). 
Память для строк выделять динамически с помощью функций malloc или calloc.
Ввод данных, сортировку и вывод результатов оформить в виде функций.
Сортировку делать с помощью qsort если возможно, если нет то писать свой вариант сортировки.
Входные и выходные параметры функции сортировки указаны в варианте. 
Входные и выходные параметры функций для ввода-вывода:

Прототип функции для ввода одной строки 
length = inp_str(char* string, int maxlen); 
// length – длина строки 
// string – введенная строка 
// maxlen – максимально возможная длина строки (размерность массива string) 

Прототип функции для вывода одной строки.
void out_str(char* string, int length, int number);
// string – выводимая строка 
// length – длина строки 
// number – номер строки 

Модифицировать программу, применив в функциях передачу параметров и возврат результатов по ссылке (с использованием указателей).
Сравнить результаты.

Варианты:
1
Расположить строки по возрастанию длины
Входные параметры:
1. Массив 
2. Размерность массива
Выходные параметры:
1. Количество перестановок
2. Длина меньшей строки 

2
Расположить строки по убыванию длины 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Количество перестановок
2. Длина большей строки 

3
Расположить строки в алфавитном порядке 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Количество перестановок 
2. Первая буква первой строки 

4
Расположить строки в обратном алфавитном порядке 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Количество перестановок
2. Длина первой строки 

5
Расположить строки по возрастанию количества слов 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Количество перестановок 
2. Первый символ последней строки 

6
Расположить строки по убыванию количества слов 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Количество перестановок 
2. Максимальное количество слов 

7
Расположить строки по возрастанию количества цифр 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Количество цифр 
2. Вторая цифра строки 

8
Расположить строки по убыванию количества цифр 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Количество перестановок 
2. Количество цифр 

9
Расположить строки по возрастанию длины первого слова 
Входные параметры:
1. Массив 
2. Размерность массива 
Выходные параметры:
1. Максимальная длина слова 
2. Количество перестановок 

10 
Расположить строки по убыванию длины первого слова
Входные параметры:
1. Массив 
2. Размерность массива
Выходные параметры:
1. Минимальная длина слова
2. Количество слов в первой строке 
?===============?

!===============!
СОСТАВИТЕЛИ:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!

!===============!
ССЫЛКИ:
http://cpp.com.ru/kr_cbook/index.html
http://cpp.com.ru/shildt_spr_po_c/index.html
http://cpp.com.ru/bogatyrev_c_unix/
http://progopedia.ru/language/c/
https://habrahabr.ru/post/304034/
https://gcc.gnu.org/onlinedocs/gcc/Standards.html
https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html
http://staff.mmcs.sfedu.ru/~ulysses/IT/C++/using_gcc.html
https://www.opennet.ru/base/dev/valgrind_memory.txt.html
!===============!
