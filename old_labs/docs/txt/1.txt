ОЗНАКОМЛЕНИЕ С ОС LINUX

ЦЕЛЬ РАБОТЫ:
Ознакомиться с операционной системой, основными командами работы с файлами и каталогами ОС Unix/Linux, текстовыми редакторами, компиляторами и утилитами.

ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ:
Лабораторная работа выполняется в среде ОС Linux Ubuntu. 
Для работы необходимо запустить  программу terminal или терминал оболочки(shell).
Оболочка, или шелл (shell) — это программа, в нашем случае названная «bash», что является сокращением от Bourne Again Shell. 
По умолчанию приглашением в Unix/Linux терменале является символ '#' или '$', 
в ответ на которое Вы можете вводить команды.
Оболочка принимает Ваши команды и передаёт их операционной системе.
Левее него указана Ваша учетная запись и имя сервера, а также текущий каталог. 
+===============+

user@localhost ~$ 

+===============+

В Linux файлы и каталоги имеют иерархическую организацию, то есть существует начальный каталог /, называемый корневым. 
В нём содержатся файлы и подкаталоги, которые в свою очереди содержат файлы и свои подкаталоги.
В сеансе работы с Linux Вашим текущим (домашним) каталогом является каталог: /home/user или ~, где user - Ваше сетевое имя.
localhost — имя сервера.
К этому каталогу Вы имеете права чтения, записи, выполнения. 
Вы не имеете права записи к каталогам, не являющимся подкаталогами вашего домашнего каталога, если их владельцы (или системный администратор) не дали Вам соответствующих прав. 
Не забывайте, что в Unix/Linux символ "слэш" - разделитель имен каталогов наклонен вправо: '/'!
Для получения справки по командам и программам служат инструкции man и info. При наборе в терминале команды man ls появится справка на команду ls:
+===============+

user@localhost ~$ man ls
LS(1)                                                         User Commands                                                        LS(1)

NAME
       ls - list directory contents
SYNOPSIS
       ls [OPTION]... [FILE]...
         ...
         ...
         ...
+===============+

Для окончания работы инструкций man и info используйте символ q.
Для экономии места показывается не все что выпадает в окне терминала, а только актуальная информация. Советую все команды повторять в своем терминале и внимательно изучать результаты выполнения команды.
В используемой оболочке имеется буфер команд, перемещение по которому производится стрелками управления курсором <вверх> и <вниз>. 
Для редактирования команды из буфера используются клавиши <влево> и <вправо>, <BackSpace> и <Delete>.
Для получения справки по командe man наберите в терминале команду man man.
+===============+

user@localhost ~$ man man
MAN(1)                                            Утилиты просмотра справочных страниц                                            MAN(1)

НАЗВАНИЕ
       man - доступ к справочным страницам
         ...
         ...
         ...
В таблице ниже показаны номера справочных разделов и описание их содержимого.

       1   Исполняемые программы или команды оболочки (shell)
       2   Системные вызовы (функции, предоставляемые ядром)
       3   Библиотечные вызовы (функции, предоставляемые программными библиотеками)
       4   Специальные файлы (обычно находящиеся в каталоге /dev)
       5   Форматы файлов и соглашения, например о /etc/passwd
       6   Игры
       7   Разное (включает пакеты макросов и соглашения), например man(7), groff(7)
       8   Команды администрирования системы (обычно, запускаемые только суперпользователем)
       9   Процедуры ядра [нестандартный раздел]
         ...
         ...

+===============+

Существует 9 справочных разделов. Это значит если набрать команду man 1 write, то появиться справка по исполняемой программе или команды оболочки (shell). Можно распознать по WRITE(1) в верхнем углу справки.
+===============+

user@localhost ~$ man 1 write
WRITE(1)                                               BSD General Commands Manual                                              WRITE(1)

NAME
     write — send a message to another user
         ...
         ...
+===============+
А если набрать команду man 2 write, то появиться справка по системным вызовам (функции, предоставляемые ядром).
Можно распознать по WRITE(2) в верхнем углу справки.

+===============+

user@localhost ~$ man 2 write

WRITE(2)                                                Linux Programmer's Manual                                               WRITE(2)

NAME
       write - write to a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t write(int fd, const void *buf, size_t count);
         ...
         ...
+===============+

Ниже перечислен список основных команд терминала оболочки(shell) и примеры использования.
ls, dir - (list)выводит содержимое каталога.
cd - (change working directory) смена рабочего каталога.
mkdir - создает каталог.
rmdir — (remove directories)удаляет каталог.
pwd - (print name of current/working directory) выводит путь текущего каталога.
tee - считывает данные из стандартного устройства ввода и записывает их на стандартное устройство вывода или в файл.
cat - объединяет файлы и направляет их на стандартный вывод.
cp - (copy) копирование файлов и каталогов.
unlink - удаляет файл с помощью системной функции unlink.
rm - (remove files or directories) удаляет файлы и каталоги.
touch - изменяет временные штампы файла. 
vi - экранно-ориентированный (визуальный) дисплейный редактор, основанный на ex.
gcc - (GNU project C and C++ compiler) Компилятор C и C++.
gdb - Отладчик GNU GDB.
make - утилита, автоматизирующая процесс преобразования файлов из одной формы в другую.

ls, dir - (list)выводит содержимое каталога. Примеры использования:
+===============+
user@localhost ~$ man ls
user@localhost ~$ ls
user@localhost ~$ ls /
user@localhost ~$ ls /home/user
user@localhost ~$ ls ~
user@localhost ~$ ls -l
user@localhost ~$ ls -a
user@localhost ~$ ls -la
user@localhost ~$ ls -Qaluh
user@localhost ~$ ls -Sal
+===============+
С помощью опций(ключей) -l или -a или совместное использование двух сразу опций -la позволяет выводить данные о каталогах и файлах в разном формате представления

cd - (change working directory) смена рабочего каталога. Примеры использования:
+===============+
user@localhost ~$ man cd 
user@localhost ~$ cd /
user@localhost /$ cd /home/user
user@localhost ~$ cd ..
user@localhost /home$ cd user/
user@localhost ~$
user@localhost ~$ cd -
user@localhost /home$
+===============+
Для быстрого набора необходимого каталога использульте для автоподстановки клавишу <Tab>.
cd /
сменить на корневой каталог
cd ..
подняться на уровень выше по файловой системе
сd ~
вернуться в домашний каталог (home directory)
cd -
вернуться в ранее рабочий каталог

mkdir - создает каталог.
+===============+
user@localhost ~$ man mkdir 
user@localhost ~$ mkdir temp 
+===============+

rmdir — (remove directories)удаляет каталог.
+===============+
user@localhost ~$ man rmdir 
user@localhost ~$ rmdir temp 
user@localhost ~$ rmdir -p temp 
+===============+

pwd - (print name of current/working directory) выводит путь текущего каталога.
Пример использования:
+===============+
user@localhost ~$ pwd 
/home/user
+===============+

tee - считывает данные из стандартного устройства ввода и записывает их на стандартное устройство вывода или в файл. 
С помощью команды tee можно создать текстовый файл с произвольным содержанием
Пример использования:
+===============+
user@localhost ~$ tee test
test
test
file
file
^C
+===============+
Для окончания ввода нужно нажать <Ctrl + c>. При вводе все строки в терминале дублируются. Но в файле будет по одной строке.

cat - объединяет файлы и направляет их на стандартный вывод.
Так же с помошью команды cat можно просмотреть содержимое файла.
Пример использования:
+===============+
user@localhost ~$ man cat
user@localhost ~$ cat test
test
file
+===============+

cp - (copy) копирование файлов и каталогов.
Пример использования:
+===============+
user@localhost ~$ man cp
user@localhost ~$ cp test /tmp
user@localhost ~$ cp -r /home/user /tmp
+===============+
Допольнительный ключ -r для команды cp означает копировать каталоги рекурсивно, 
то есть все файлы и подкаталоги с файлами автоматически будут скопированы. Короче будет скопирована вся папка.

unlink - удаляет файл с помощью системной функции unlink.
Пример использования:
+===============+
user@localhost ~$ man unlink
user@localhost ~$ unlink /tmp/test
+===============+

rm - (remove files or directories) удаляет файлы и каталоги.
Пример использования:
+===============+
user@localhost ~$ man rm
user@localhost ~$ rm -r /tmp/user
+===============+
Допольнительный ключ -r для команды rm означает удалить каталог рекурсивно, 
то есть все файлы и подкаталоги с файлами автоматически будут удалены.

touch - изменяет временные штампы файла. 
С помощью команды touch можно создать пустой файл.
Пример использования:
+===============+
user@localhost ~$ man touch
user@localhost ~$ touch empty.file
+===============+

vi - экранно-ориентированный (визуальный) дисплейный редактор, основанный на ex. 
Самый старый текстовый редактор для терминала. Есть практически в любой ОС Linux по умолчанию.
Если даже в системе не будет никаких текстовых редакторов, то с вероятностью 99% что vi будет работать.
Поэтому основным командам vi стоит научиться.
Пример использования:
+===============+
user@localhost ~$ man vi
user@localhost ~$ vi empty.file
+===============+
В любой момент при работе в редакторе Vi вы находитесь в одном из трёх режимов редактора:
-командный режим (command mode); 
-режим ввода (insert mode); 
-режим последней строки (last line mode). 

РЕЖИМЫ: Ввода == ESC ====> Командный == :q ==> Редактора ed
            ^                  |     ^                |
            +----aAiIcCrRs <---+     +----- vi -------+
Основной ввод и редактирование текста осуществляется в режиме ввода. 
При использовании редактора vi основное время, скорее всего, будет проводиться именно в этом режиме. 
Переход в режим ввода из командного режима осуществляется клавишей <i> (сокращение от insert). 
Находясь в режиме ввода, можно вводить текст в то место, куда указывает курсор. 
Выход из режима ввода в командный режим осуществляется клавишей <Esc>.
Для выхода из редактора Vi без сохранения изменений, сделанных в файле, используется команда <:q!>
Для выхода из редактора vi с сохранением сделанных изменений используется команда <:wq>
Чтобы сохранить файл, но не выходить из редактора Vi, используется команда <:w>

Пример самой простой программы:
//--- simple_hard.c
void main()
{
}
//---------------

Вот более популярный вариант:
//--- simple.c
int main(int argc, char **argv)
{
	return 0;//255//256//-1
}
//---------------

gcc - (GNU project C and C++ compiler) Компилятор C и C++.
С помощью gcc можно сделать компиляцию-сборку простейшей программы:
+===============+
user@localhost ~$ gcc simple.c
user@localhost ~$ ls
a.out  simple.c
+===============+

Если запускать без опций(ключей), то по умолчанию программа будет собрана в выходной файл a.out.
У GCC великое множество опций, которые описаны в man gcc.
+===============+
user@localhost ~$ man gcc
+===============+

Компилятор распознаёт язык программирования исходного кода, применённый в файле, по расширению файла.
Например: *.c — C, *.cc — C++, *.S — ассемблер в AT&T нотации (не Intel!). 
Но язык кода можно определить и ключом -x <язык>.

Следующая команда с опцией -с собирает объектный файл:
+===============+
user@localhost ~$ gcc -c simple.c
user@localhost ~$ ls
simple.c  simple.o
+===============+

На выходе получился объектный файл simple.o. 
Один или несколько объектных файлов могут быть связаны в соответствующий исполняемый файл.
Чтобы получить полноценный исполняемый файл нужно выполнить команду сборки c опцией -o <имя исполняемого файла> и подставить в строку сборки имя объектного файла simple.o:
+===============+
user@localhost ~$ gcc simple.o -o simple
user@localhost ~$ ls
simple simple.c  simple.o
user@localhost ~$ ./simple
user@localhost ~$
+===============+

После правильного запуска программы ./simple если все сделано верно ничего не увидим.
Программа simple ничего не делает и только возвращает 0.
В UNIX-подобных системах, по завершении работы программы, принято возвращать в командную оболочку целое число - в случае успешного завершения ноль,  в противном случае любое другое значение в диапозоне от 1 до 255.
Интерпретатор оболочки автоматически присвоит полученное значение переменной среды с именем $?. 
$? — это переменная, которая содержит выходной статус последней запущенной команды.
Просмотреть её содержимое можно с помощью команды echo $?:
+===============+
user@localhost ~$ ./simple
user@localhost ~$ echo $?
0
+===============+

Символы <./> означают что программа будет запущена из текущего каталога.
Почему в команде запуска на исполнение файла из текущего каталога необходимо явно указывать путь к файлу?
Если путь к исполняемому файлу не указан явно, оболочка, интерпретируя команды, ищет файл в каталогах, список которых задан системной переменной PATH.
+===============+
user@localhost ~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+===============+

Каталоги в списке разделены символом двоеточия.
При поиске файлов, оболочка просматривает каталоги в том порядке, в котором они перечислены в списке.
По умолчанию, из соображений безопасности, текущий каталог <.> в список не внесен, соответственно, оболочка исполняемые файлы искать в нем не будет.

Переменные окружения — это именованные переменные, которые затрагивают командную оболочку и порядок взаимодействия с пользователем, содержащие значения, используемые одним или несколькими приложениями.

В более общем контексте, каждый процесс имеет некоторое "окружение" (среду исполнения), т.е. набор переменных, к которым процесс может обращаться за получением определенной информации. 
В этом смысле командная оболочка подобна любому другому процессу.
Каждый раз, когда запускается командный интерпретатор или терминал, для него создаются переменные, соответствующие переменным окружения.
Изменение переменных или добавление новых переменных окружения заставляет оболочку обновить свои переменные, и все дочерние процессы (и команды, исполняемые ею) наследуют это окружение.

PATH содержит список каталогов, в которых система ищет исполняемые файлы.
HOME содержит путь к домашнему каталогу текущего пользователя.
HOSTNAME содержит сетевое имя хоста.
PWD содержит рабочий каталог.

Чтобы посмотреть все доступные переменные окружения можно воспользоваться утилитой env:
+===============+
user@localhost ~$ echo $HOSTNAME
user@localhost ~$ localhost.localdomain
user@localhost ~$ env
................. 
+===============+

Напишем простую программу для вывода сообщения на экран:
//--- hello_world.c
#include <stdio.h>
int main( int argc, char *argv[] ) {
   printf("Hello, world!\n" );
}
//---------------

+===============+
user@localhost ~$ gcc -c hello_world.c
user@localhost ~$ gcc hello_world.o -o hello_world
user@localhost ~$ ls 
hello_world  hello_world.c  hello_world.o
user@localhost ~$ ./hello_world
Hello, world!
+===============+

gdb - Отладчик GNU GDB.
Утилита GNU GDB довольно многофункциональная.
Пошаговая отладка - лишь одна из ее возможностей.
Чтобы программу можно было отлаживать, она должна быть откомпилирована с ключом -g.
Соберём программу снова, но уже с включением отладочной информацией.
Запустим отладчик GDB, загрузив в него нашу программу для отладки.
Чтобы запустить программу внутри отладчика, даётся команда run.
Чтобы посмотреть исходный код, даётся команда list.
+===============+
user@localhost ~$ gcc -g -c hello_world.c
user@localhost ~$ gcc hello_world.o -o hello_world
user@localhost ~$ gdb hello_world
+===============+

За более подробной информацией всегда можно обратиться к встроенному описанию программы (info gdb) или руководством по пользованию (man gdb).
Ниже представлен короткий список наиболее часто встречающихся команд отладчика GDB:
backtrace – выводит весь путь к текущей точке останова, то есть названия всех функций, начиная от main(); иными словами, выводит весь стек функций;
break – устанавливает точку останова; параметром может быть номер строки или название функции; 
clear – удаляет все точки останова на текущем уровне стека (то есть в текущей функции);
continue – продолжает выполнение программы от текущей точки до конца;
delete – удаляет точку останова или контрольное выражение;
display – добавляет выражение в список выражений, значения которых отображаются каждый раз при остановке программы;
finish – выполняет программу до выхода из текущей функции; отображает возвращаемое значение,если такое имеется;
info breakpoints – выводит список всех имеющихся точек останова;
info watchpoints – выводит список всех имеющихся контрольных выражений;
list – выводит исходный код; в качестве параметра передаются название файла исходного кода, затем, через двоеточие, номер начальной и конечной строки;
next – пошаговое выполнение программы, но, в отличие от команды step, не выполняет пошагово вызываемые функции;
print – выводит значение какого-либо выражения (выражение передаётся в качестве параметра);
run – запускает программу на выполнение;
set – устанавливает новое значение переменной
step – пошаговое выполнение программы;
watch – устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится;
quit – выход из отладчика.

make - утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. 
Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка в исполняемые файлы или библиотеки.
Утилита make автоматически определяет какие части большой программы должны быть перекомпилированы, и выполняет необходимые для этого действия.
Утилита использует специальные make-файлы, в которых указаны зависимости файлов друг от друга и правила для их удовлетворения. 
На основе информации о времени последнего изменения каждого файла make определяет и запускает необходимые программы.
Перед тем, как использовать make, вы должны создать так называемый make-файл (Makefile).
Обычно, вам имеет смысл давать своему make-файлу имя makefile, либо Makefile. 
Если вы хотите использовать "нестандартное" имя для вашего make-файла, вы можете указать его в командной строке, используя опции -f или —file.
Простой make-файл состоит из "правил" (rules) следующего вида: 
цель ... : пререквизит ...
        команда

Правило (rule) описывает, когда и каким образом следует обновлять файлы, указанные в нем в качестве цели. 
Обычно, цель (target) представляет собой имя файла, который генерируется в процессе работы утилиты make. 
Пререквизит (prerequisite) - это файл, который используется как исходдные данные для порождения цели. 
Очень часто цель зависит сразу от нескольких файлов.
Команда - это действие, выполняемое утилитой make. 
В правиле может содержаться несколько команд - каждая на свое собственной строке. 

Важное замечание: строки, содержащие команды обязательно должны начинаться с символа табуляции! 

По умолчанию, make начинает свою работу с первой встреченной цели (кроме целей, чье имя начинается с символа <.>). 
Эта цель будет являться главной целью по умолчанию (default goal). 
Главная цель (goal) - это цель, которую стремится достичь make в качестве результата своей работы. 
Таким образом, когда вы даете команду make, утилита make читает make-файл из текущей директории и начинает его обработку с первого встреченного правила сверху вниз.
Пример простого make-файла для примера hello_world.c:
#--- Makefile
hello_world : hello_world.o 
	gcc hello_world.o -o hello_world
hello_world.o : hello_world.c
	gcc -c hello_world.c 
clean :
	rm hello_world hello_world.o
#---------------

Пример использования make-файла:
+===============+
user@localhost ~$ make
gcc -c hello_world.c
gcc hello_world.o -o hello_world
+===============+


?===============?
ЗАДАНИЕ:
 1. Выполнить команды help, ls, cd, pwd, mkdir, rmdir.
 2. Изучить описания этих команд с помощью инструкций man и info.
 3. Изучить описания команды script.
 4. Создать текстовый файл с произвольным содержанием при помощи команды tee. 
 5. Просмотреть содержимое файла при помощи команды cat и исправить в нем ошибки при помощи текстового редактора vi.
 6. Изучить справку на команды cp, unlink.
 7. Сделать копию файла командой cp, удалить ее командой unlink, запротоколировав эти действия с помощью script.
 8. Создать в редакторе vi файл test.c.
 9. Подключить include-файл stdio.h, в функции main обеспечить вывод строки, например, “Hello, world!” и вызов функции sleep с параметром 10.
 10. Сохранить файл и откомпилировать программу с помощью gcc.
 11. Изучить сообщения компилятора и исправить ошибки (для вызова функции sleep необходим include-файл unistd.h).
 12. Перекомпилировать программу, при отсутствии ошибок запустить на выполнение.
 13. Изменить значение параметра функции sleep, перекомпилировать программу, запустить и оценить изменения.
 14. Запустить отладчик gdb, освоить основные его команды, перечисленные в лекционном материале.
 15. Написать и отладить make-файл для компиляции указанного с-файла и запуска на исполнение программы при отсутствии ошибок компиляции.
 16. Изучить справку к команде ps, выполнить ее с ключами -a, -e, a, u, x, ax, записать результаты в файл, например: ps -e > ps.log.
 17. Установив в тексте программы значение параметра функции sleep выше 20, перекомпилировать программу.
 18. Выполнив еще одно подключение к системе (в новом окне терминала), вернуться к первому сеансу, запустить программу test, перейти ко второму терминалу, определить PID запущенной программы, снять ее с выполнения утилитой kill. Вернуться к первому сеансу, оценить действие утилиты. Завершить второй сеанс.
 19. Изучить справку к файловому менеджеру Midnight Commander, запустить его, изучить перечень доступных команд, сочетания клавиш для выполнения часто применяемых команд, особенности встроенного текстового редактора.
?===============?

!===============!
Ссылки:
1. tproger.ru/translations/bash-cheatsheet/
2. cpp.com.ru/shildt_spr_po_c/index.html
3. gcc.gnu.org/
4. www.opennet.ru/docs/RUS/gdb/
5. www.opennet.ru/docs/RUS/gnumake/
6. rus-linux.net/nlib.php?name=/MyLDP/algol/gnu_make/gnu_make_3-79_russian_manual.html
7. https://tproger.ru/translations/bash-cheatsheet/
8. http://rus-linux.net/MyLDP/BOOKS/abs-guide/flat/abs-book.html
9. http://gun.cs.nstu.ru/cpp/gdb-html.tgz
10. https://habrahabr.ru/post/47163/
11. https://habrahabr.ru/post/52871/
!===============!

!===============!
Составители:
Гунько А.В., канд. техн. наук, доц. НГТУ
Чистяков Н.А., инженер НГТУ
!===============!
